[["processing-data.html", "Chapter 3 Processing Data", " Chapter 3 Processing Data Most of the time, we need to make some changes to a dataset to prepare it for analysis. This could involve adding new variables, “cleaning” existing variables, changing the level of measurement for a variable, altering the labels of a variable, or even combining multiple datasets. We refer to these kinds of changes as “processing” the data. This section is about the common tools that are used for data processing in this course. "],["missing.html", "3.1 Label Missing Observations in a Dataset", " 3.1 Label Missing Observations in a Dataset Sometimes we will work with survey data that has observations with numeric codes that are not aligned with a response of interest. For example, the numeric code -9 might signify that a person did not actually answer the survey question. We want to label this particular observation as “missing”. 3.1.1 Problem You want to label missing observations. 3.1.2 Solution These instructions begin with the premise that you already know which variable values correspond to missing values.The codebook should indicate which codes correspond to missing data. Use indexing to isolate the observations that have missing values. Assign those observations a value of NA. dataset$variable[dataset$variable == missing_value] &lt;- NA Here we are looking at the variable hillary_therm in the anes dataset, and we label all observations that take the value -9 as missing. # labeling -9 as missing anes$hillary_therm[anes$hillary_therm == -9] &lt;- NA 3.1.3 Troubleshooting In order to label the missing observations you have to first understand what all of the values of the variable are and/or should be. That information comes from the codebook for the data. For example, if you know that a variable is supposed to take values from 0 to 10, then a value of -99 is probably a code for a missing observation. You will generally want to look at a frequency table prior to labeling the missing values and after labeling the missing values. That will indicate whether you have done it correctly. "],["add-variable.html", "3.2 Add a New Variable to a Dataset", " 3.2 Add a New Variable to a Dataset When we want to make a change to a variable, it is a good practice to create a new variable rather than changing the existing variable. 3.2.1 Problem You want to add a variable to a dataset. 3.2.2 Solution - Basic Provide a name for the new variable. Use the $ operator to create the variable in the data data$new_variable_name. Assign values to the new variable. Often we are assigning the new variable the values of the old variable as a preliminary step to some other kind of transformation/processing. data$new_variable &lt;- data$old_variable. # assign an old variable to a new variable name dataset$new_variable &lt;- dataset$old_variable Below we assign the values of the variable ft.dem to a new variable called dem_therm. The dataset is named “nes”. nes$dem_therm &lt;- nes$ft.dem 3.2.3 Solution - tidyverse Assign the dataset to itself. Use the pipe operator %&gt;% at the end of that line of code. Use the mutate() function. The argument for the function is setting the name of the new variable and then assigning it values using an equal sign. # use mutate to turn an old variable into a new variable dataset &lt;- dataset %&gt;% mutate(new_variable = old_variable) Below we assign the values of the variable ft.dem to a new variable called dem_therm. The dataset is named “nes”. # assign data to itself nes &lt;- nes %&gt;% # use mutate() to assign values to the new variable mutate(dem_therm = ft.dem) 3.2.4 Troubleshooting No common mistakes yet. "],["additive.html", "3.3 Create an Additive Index", " 3.3 Create an Additive Index 3.3.1 Problem You want to make some arithmetic adjustment to a variable. 3.3.2 Solution You have already added a variable to a dataset Inside your mutate() function add, subtract, multiply, or divide variables by other variables or by constants. # assign dataset to itself dataset &lt;- datasets %&gt;% # use mutate() with some arithmetic in the argument mutate(new_variable = old_variable + some_number) Below we create a variable avg_demfeel that is the average feeling thermometer of ft.obama, ft.dem, and ft.biden.pre. # assign dataset to itself nes &lt;- nes %&gt;% # use mutate() to add the three variables and divide to get the average mutate(avg_demfeel = (ft.obama + ft.dem + ft.biden.pre)/3) 3.3.3 Troubleshooting It may be helpful to test out your math problem first to make sure it gives you the results you are looking for. "],["factor.html", "3.4 Create a Factor Variable", " 3.4 Create a Factor Variable In R, nominal level variables are called “factors.” This section explains how to create a factor. 3.4.1 Problem You want to transform a variable into a factor. 3.4.2 Solution Decide on what to name the factor variable. Use as.factor() to assign the old variable values to the new variable. See Section 3.2. Use levels() to assign labels to the values of the variable. The levels should be provided as a list in c() with the names of the levels in quotation marks. It would follow the general template below. # define the variable as a factor data$newvariable &lt;- as.factor(data$oldvariable) # add the levels levels(data$newvariable) &lt;- c(&quot;label1&quot;, &quot;label2&quot;, &quot;labelk&quot;) Transform battleground2020 in the states from a numeric dummy variable into a factor. # the frequency table for the old variable freqC(states$battleground2020, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-10)Frequency Distribution of states$battleground2020 (Battleground in 2020 election? ) ## ## Frequency Percent ## ------ ---------- -------- ## 0 37 74.00 ## 1 13 26.00 ## Total 50 100.00 # call the new variable `battlefact` states$battlefact &lt;- as.factor(states$battleground2020) # assign the levels levels(states$battlefact) &lt;- c(&quot;not a battleground&quot;, &quot;battleground&quot;) # the frequency table for the new variable freqC(states$battlefact, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-10)Frequency Distribution of states$battlefact ## ## Frequency Percent ## ------------------- ---------- -------- ## not a battleground 37 74.00 ## battleground 13 26.00 ## Total 50 100.00 3.4.3 Troubleshooting There has to be a level provided for each value of the variable. That is why this process should occur after a variable has been cleaned. The level names do not have to be unique. That means this could be used as a (somewhat clunky) method of recoding a variable by collapsing its categories. "],["numeric.html", "3.5 Create a Numeric Variable", " 3.5 Create a Numeric Variable Interval level variables are classified as “numeric”. 3.5.1 Problem You want to transform an existing variable into a numeric variable. 3.5.2 Solution Decide on what to name the numeric variable. It could be the same name as the old variable. Use as.numeric() to assign the old variable values to the new variable. It would follow the general template below. data$newvariable &lt;- as.numeric(data$oldvariable) Here is an example that converts the seven-point party identification scale into a numeric variable. # frequency table of the original variable `partyid7` freqC(nes$partyid7, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-12)Frequency Distribution of nes$partyid7 (PRE: SUMMARY: Party ID) ## ## Frequency Percent Cum.Percent ## ------------------------------ ---------- -------- ------------ ## 1. Strong Democrat 1961 23.78 23.78 ## 2. Not very strong Democrat 900 10.92 34.70 ## 3. Independent-Democrat 975 11.83 46.53 ## 4. Independent 968 11.74 58.27 ## 5. Independent-Republican 879 10.66 68.93 ## 6. Not very strong Republican 832 10.09 79.02 ## 7. Strong Republican 1730 20.98 100.00 ## Total 8245 100.00 NA # make `partyid7` numeric nes$pid7 &lt;- as.numeric(nes$partyid7) # frequency table of the new variable `pid7` freqC(nes$pid7, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-12)Frequency Distribution of nes$pid7 ## ## Frequency Percent ## ------ ---------- -------- ## 1 1961 23.78 ## 2 900 10.92 ## 3 975 11.83 ## 4 968 11.74 ## 5 879 10.66 ## 6 832 10.09 ## 7 1730 20.98 ## Total 8245 100.00 3.5.3 Troubleshooting Have not come across any problems yet. "],["ordinal.html", "3.6 Create an Ordinal Variable", " 3.6 Create an Ordinal Variable 3.6.1 Problem You want to transform an existing variable into an ordinal variable. 3.6.2 Solution Decide on what to name the ordinal variable. It could be the same name as the old variable. However, this could become confusing in your code. Use as.ordered() to assign the old variable values to the new variable. Use levels() to assign labels to the values of the variable. The levels should be provided as a list in c() with the names of the levels in quotation marks. It would follow the general template below. # define the variable as ordinal data$newvariable &lt;- as.ordered(data$oldvariable) # add the levels levels(data$newvariable) &lt;- c(&quot;label1&quot;, &quot;label2&quot;, &quot;labelk&quot;) Transform abort4 in the nes from a factor into an ordinal variable. # the frequency table for the old variable freqC(nes$abort4, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-14)Frequency Distribution of nes$abort4 ## ## Frequency Percent ## ----------------------------- ---------- -------- ## never 870 11.01 ## rape, incest, life of mother 1916 24.25 ## yes with limits 1097 13.89 ## always 4017 50.85 ## Total 7900 100.00 # call the new variable `abort4` nes$abort4 &lt;- as.ordered(nes$abort4) # assign the levels levels(nes$abort4) &lt;- c(&quot;never&quot;, &quot;some conditions&quot;, &quot;more conditions&quot;, &quot;always&quot;) # the frequency table for the new variable freqC(nes$abort4, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-14)Frequency Distribution of nes$abort4 ## ## Frequency Percent Cum.Percent ## ---------------- ---------- -------- ------------ ## never 870 11.01 11.01 ## some conditions 1916 24.25 35.27 ## more conditions 1097 13.89 49.15 ## always 4017 50.85 100.00 ## Total 7900 100.00 NA 3.6.3 Troubleshooting There has to be a level provided for each value of the variable. That is why this process should occur after a variable has been cleaned. The key reason for treating a variable as ordinal rather than nominal in R is to calculate the “cumulative percent” column in a frequency table. "],["indicator.html", "3.7 Create an Indicator/Dummy Variable", " 3.7 Create an Indicator/Dummy Variable An indicator variable (also known as a dummy variable) is a conversion of an existing variable such that it takes the value of 1 when the existing variable meets some criteria and the value of 0 otherwise. For example, if we want to plot the proportion of observations who voted for Joe Biden in 2020, then we would first make an indicator variable out of the nominal variable presvote2020. 3.7.1 Problem You want to create an indicator/dummy variable. 3.7.2 Solution Assign the dataset to itself. Use the pipe operator |&gt; at the end of that line of code. Use the mutate() function. Create a name for the indicator variable. Set the indicator variable as being equal to a numeric version of whether the old variable satisfies some criteria. # assign the dataset to itself dataset &lt;- dataset |&gt; # use mutate() to create the indicator variable mutate(indicator_variable = as.numeric(some_criteria)) Here we create an indicator variable called biden_vote that takes a value of 1 for all observations in which presvote2020 was equal to Joe Biden. # assign the dataset to itself nes &lt;- nes |&gt; #use mutate() to create the indicator variable mutate(biden_vote = as.numeric(presvote2020 == &quot;1. Joe Biden&quot;)) # check the new variable freqC(nes$biden_vote, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-16)Frequency Distribution of nes$biden_vote ## ## Frequency Percent ## ------ ---------- -------- ## 0 2740 43.65 ## 1 3537 56.35 ## Total 6277 100.00 3.7.3 Troubleshooting The criteria is written as variable, logical operator, and value of the variable. The values of categorical variables must be in quotation marks. The most common error is that the value of the old variable is not written correctly. If the above example did not include the “1.” in front of “Joe Biden”, then the indicator variable would have returned values of 0 for all of the observations. "],["filter.html", "3.8 Filter your Data", " 3.8 Filter your Data 3.8.1 Problem You want to create a subset of your data based on some criteria. 3.8.2 Solution Provide a name for the subset of data you are creating. Assign the existing dataset to the new data object. Use the pipe %&gt;%. Use filter(). The pipe inherits the dataset from the prior step, so the only argument is the criteria for the subset. The criteria use relational logic: == equal to &gt; greater than &lt; less than &gt;= greater than or equal to &lt;= less than or equal to != not equal to | or, if there are multiple criteria &amp; and, if there are multiple criteria Follow the template below. newdata &lt;- old_data %&gt;% filter(criteria) Here we create a subset that only includes people who voted for Biden # frequency of `biden_vote` in full dataset freqC(nes$biden_vote, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-18)Frequency Distribution of nes$biden_vote ## ## Frequency Percent ## ------ ---------- -------- ## 0 2740 43.65 ## 1 3537 56.35 ## Total 6277 100.00 # create a subset of `nes` data that only includes Biden voters bidenites &lt;- nes %&gt;% filter(biden_vote == 1) # frequency of a `biden_vote` in subset freqC(bidenites$biden_vote, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-18)Frequency Distribution of bidenites$biden_vote ## ## Frequency Percent ## ------ ---------- -------- ## 1 3537 100.00 ## Total 3537 100.00 3.8.3 Troubleshooting The criteria is written as variable, logical operator, and value of the variable. The values of categorical variables must be in quotation marks. "],["sum.html", "3.9 Summarize Data Using Means", " 3.9 Summarize Data Using Means 3.9.1 Problem You want to make a summary dataset that shows the mean of one variable for each value of some other variable. 3.9.2 Solution Assign the old data to a new data object. Use the pipe %&gt;% at the end of the line of code. Use group_by(). The argument is the variable that you want to use to find the means of some other variable. Use the pipe %&gt;% at the end of the line of code. Use summarise(). Create a name for the summary variable. Set the summary variable as being equal to the mean of the variable that you want to take the mean of. newdata &lt;- old_data %&gt;% group_by(group_variable) %&gt;% summarise(summary_variable = mean(mean_variable)) Here we calculate the mean feelings towards Obama, ft.obama, by party identification, partyid7. # assign old data to a new data object partymeans &lt;- nes %&gt;% # use group_by() to group the data by partyid7 group_by(partyid7) %&gt;% # calculate the means of ft.obama summarise(average = wtd.mean(ft.obama, na.rm = T, w = wt)) # show the summary dataset partymeans ## # A tibble: 8 × 2 ## partyid7 average ## &lt;ord&gt; &lt;dbl&gt; ## 1 1. Strong Democrat 93.3 ## 2 2. Not very strong Democrat 83.0 ## 3 3. Independent-Democrat 82.0 ## 4 4. Independent 63.0 ## 5 5. Independent-Republican 37.7 ## 6 6. Not very strong Republican 44.2 ## 7 7. Strong Republican 18.4 ## 8 &lt;NA&gt; 77.9 3.9.3 Troubleshooting For survey data use wtd.mean(). Use mean() for non-survey data. "],["transform_nom.html", "3.10 Transform an interval variable into a nominal variable", " 3.10 Transform an interval variable into a nominal variable Many of the tools we use to analyze the relationship between two variables require that the independent variable is nominal or ordinal. In those cases, it can be useful to transform an interval independent variable into a nominal or ordinal version. 3.10.1 Problem You want to transform an interval variable into a nominal variable. 3.10.2 Solution Assign the dataset to itself. Use the pipe operator |&gt; at the end of that line of code. Use the mutate() function. Create a name for the new nominal variable. Set the nominal variable as being equal to a factor() of whether the old variable is greater than some value. The choice of value is up to the researcher, but it should make sense as a way to divide the original variable between “high” and “low”. Place a comma at the end of your criteria, and press return. Use the argument labels = to assign levels to the values of the variable. The levels should be provided as a list in c() with the names of the levels in quotation marks. # assign the dataset to itself dataset &lt;- dataset |&gt; # use mutate to create the nominal variable mutate(new_nominal = factor( # the criteria for determining high vs. low values old_interval &gt; some_value, # assign the levels to the new variable labels = c(&quot;low&quot;, &quot;high&quot;))) In the example below we transform the Obama feeling thermometer, ft.obama, into a nominal variable, high_obama. The interval variable ft.obama ranges from 0 to 100, so we set 60 and above as the value for “high”. nes &lt;- nes |&gt; mutate(high_obama = factor(ft.obama &gt; 60, labels = c(&quot;cool Obama feelings&quot;, &quot;warm Obama feelings&quot;))) freqC(nes$high_obama, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-22)Frequency Distribution of nes$high_obama ## ## Frequency Percent ## -------------------- ---------- -------- ## cool Obama feelings 3653 44.74 ## warm Obama feelings 4512 55.26 ## Total 8165 100.00 3.10.3 Troubleshooting Make sure that you have the correct number of closing parentheses. Following the template above, there should be three parentheses at the end. Remember that we are converting an interval variable, so the value of that variable should be a number without quotation marks. "],["transform_ord.html", "3.11 Transform an interval variable into an ordinal variable", " 3.11 Transform an interval variable into an ordinal variable Many of the tools we use to analyze the relationship between two variables require that the independent variable is ordinal. In those cases, it can be useful to transform an interval independent variable into an ordinal version. 3.11.1 Problem You want to transform an interval variable into an ordinal variable. 3.11.2 Solution Assign the dataset to itself. Use the pipe operator |&gt; at the end of that line of code. Use the mutate() function. Create a name for the new ordinal variable. Set the ordinal variable as being equal to a factor Inside the factor() function, use the function transformC(). This function will take four arguments.Each argument is separated by a comma. The first argument for transformC() is set type equal to ‘cut’. The second argument is set x equal to the name of interval variable. The third argument is set cutpoints equal to a list of the values you want to use to split the interval variable into ordinal categories. Alternatively, the third argument is set groups equal to the number of ordinal categories you want. The fourth argument is set confirm equal to F. Close the parentheses to indicate that this is the end of the transformC() function, type a comma, and press return. Use the argument labels = to assign levels to the values of the variable. The levels should be provided as a list in c() with the names of the levels in quotation marks. Some variation of “low”, “medium”, “high” would make sense for an ordinal variable with three categories. # assign dataset to itself dataset &lt;- dataset |&gt; # use `mutate()` to create a new variable as a factor mutate(new_ordinal = factor( # Use transformC() to create the ordinal variable transformC(type = &#39;cut&#39;, # second argument x = interval_variable x = old_interval, # third argument set cutpoints cutpoints = c(value1, value2), # fourth argument confirm = F confirm = F), # assign levels labels = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;))) In the example below we transform the Obama feeling thermometer, ft.obama, into a ordinal variable, obama_ord. The interval variable ft.obama ranges from 0 to 100 and is supposed to act as thermometer, so we set the cutpoints at 40 and 60. Values below 40 are “cold”, values between 40 and 60 are “mid”, and values above 60 are “warm”. # assign dataset to itself nes &lt;- nes |&gt; # use `mutate()` to create a new variable as a factor mutate(obama_ord = factor( # Use transformC() to create the ordinal variable transformC(type = &#39;cut&#39;, # second argument x = interval_variable x = ft.obama, # third argument set cutpoints cutpoints = c(40, 60), # fourth argument confirm = F confirm = F), # assign levels labels = c(&quot;cold&quot;, &quot;mid&quot;, &quot;warm&quot;))) # check our work freqC(nes$obama_ord, plot = F) ## =========================================================================== ## Describing Distribution of Values with Frequency Table ## =========================================================================== ## ## ## Table: (\\#tab:unnamed-chunk-24)Frequency Distribution of nes$obama_ord ## ## Frequency Percent Cum.Percent ## ------ ---------- -------- ------------ ## cold 2290 28.05 28.05 ## mid 891 10.91 38.96 ## warm 4984 61.04 100.00 ## Total 8165 100.00 NA 3.11.3 Troubleshooting One reason to use cutpoints instead of groups is that it is not clear how to discover where the cutpoints are are when you only use groups. With the ‘groups’ argument, transformC() will try to make the categories have roughly equivalent numbers of observations, and that may not always make sense for the actual data. Be careful about syntax errors like missing commas and parentheses. This code uses functions inside of functions, so make sure that you have the right parentheses in the right places. "],["pivot_wide.html", "3.12 Pivot a Dataframe Wide", " 3.12 Pivot a Dataframe Wide Data that we collect out in the wild is not always organized around our chosen unit of analysis. Look at the data below: knitr::kable(urban) city type value Atlanta voting 43 Atlanta protests 12 Dover voting 78 Dover protests 29 Rochester voting 37 Rochester protests 52 Here, each row represents a city and a type of political participation. This is not what we want. We want the unit of analysis to be cities, so each row should just represent one city, with different columns for the different types of participation. Pivoting data is one way to reorganize a dataset so that the rows of the data match the unit of analysis. A “wide” pivot is when we turn the values of a variable into columns of the dataset. 3.12.1 Problem You want to do a “wide” pivot that reorganizes a dataset by making separate columns for the values of a variable. 3.12.2 Solution Create a new data object. Assign the old dataset to the new object. Use the pipe operator |&gt; at the end of that line of code. Use the pivot_wider() function, specifying at least two arguments. The first argument, names_from, is to provide the name of the variable whose values are being converted into columns. The second argument, values_from, provides the values that will be used to populate the new columns. # assign the old dataset to a new object new_data &lt;- old_data |&gt; # use pivot_wider() pivot_wider( # use `names_from` to specify the variable that is being turned into columns names_from = some_variable, # use `values_from` to specify the variable that provides values for the columns values_from = some_other_variable ) In the example below we perform a wide pivot on the urban dataset to make cities into the unit of analysis. Specifically, we will create separate columns for each type of political participation – voting and protests. # assign the old dataset to a new object city_part &lt;- urban |&gt; # use pivot_wider() pivot_wider( # use `names_from` to specify the variable that is being turned into columns names_from = type, # use `values_from` to specify the variable that provides values for the columns values_from = value ) # look at the data knitr::kable(city_part) city voting protests Atlanta 43 12 Dover 78 29 Rochester 37 52 3.12.3 Troubleshooting In more complicated datasets, it will probably be necessary to use the id_cols argument in pivot_wider() to specify the variable that identifies all of the unique observations in a dataset. "],["pivot_long.html", "3.13 Pivot a Dataframe Long", " 3.13 Pivot a Dataframe Long Data that we collect out in the wild is not always organized around our chosen unit of analysis. Look at the data below: knitr::kable(urban2) city 1981 1999 2003 Atlanta 43 45 47 Dover 78 81 84 Rochester 37 47 57 Here we have the voter turnout data for three cities in 1981, 1999, and 2003. The unit of analysis cities. In this case, we are interested in how cities perform over time, so we want the unit of analysis to be city-year instead of cities. Pivoting data is one way to reorganize a dataset so that the rows of the data match the unit of analysis. A “long” pivot is when we collapse the columns of a dataset into the values of a variable. 3.13.1 Problem You want to do a “long” pivot that reorganizes your data such that a number of columns are collapsed into the values of two variables. 3.13.2 Solution Create a new data object. Assign the old dataset to the new object. Use the pipe operator |&gt; at the end of that line of code. Use the pivot_longer() function, specifying at least three arguments. The first argument, cols, is to provide the name of the columns that are being collapsed. The second argument, names_to, provides the new name of the variable that will whose values will now be the names of the collapsed columns The third argument, values_to, provides the name of the new variable that inherits the values from the collapsed columns. # assign the old dataset to a new object new_data &lt;- old_data |&gt; # use pivot_longer() pivot_longer( # use `cols` to specify the variables that are being collapsed cols = first_column:last_column, # use `names_to` to specify the new variable that holds the column names names_to = variable_name, # use `values_to` to specify the variable that holds the new values values_to = other_variable ) In the example below we perform a long pivot on the urban2 dataset to make city-year into the unit of analysis.Specifically, we will collapse the variable 1981, 1999, and 2003 into one new variable called year. The values will be placed in a variable called turnout. # assign the old dataset to a new object city_year &lt;- urban2 |&gt; # use pivot_longer() pivot_longer( # use `cols` to specify the variables that are being collapsed cols = `1981`:`2003`, # use `names_to` to specify the new variable that holds the column names names_to = &quot;year&quot;, # use `values_to` to specify the variable that holds the new values values_to = &quot;turnout&quot; ) # look at the data knitr::kable(city_year) city year turnout Atlanta 1981 43 Atlanta 1999 45 Atlanta 2003 47 Dover 1981 78 Dover 1999 81 Dover 2003 84 Rochester 1981 37 Rochester 1999 47 Rochester 2003 57 3.13.3 Troubleshooting The names of the columns can also be provided as a list using c(). "],["key.html", "3.14 Creating a ‘Key’ Variable", " 3.14 Creating a ‘Key’ Variable It is often helpful to have a variable that uniquely identifies each of your observations. This kind of ‘id’ or ‘key’ variable is particularly useful when pivoting or merging datasets. 3.14.1 Problem You want to create a ‘key’ variable that uniquely identifies all of your observations. 3.14.2 Solution Assign the dataset to itself. Use the pipe operator |&gt; at the end of that line of code. Use the mutate() function. Create a name for the new variable. Something simple like key or id works. Set the new variable equal to the function paste(). Inside the paste() list the variables that will be used to create the unique identifier. Each variable should be separated by a comma. Add a comma after the last variable listed and then press return. Set the argument sep equal to “-”. # assign dataset to itself dataset &lt;- dataset |&gt; # use mutate to create `key` set to `paste()` mutate(key = paste( # list the variables that uniquely identify observations first_variable, second_variable, # set a value for the `sep` argument sep = &quot;-&quot; )) Look at the city_year data we created in the long pivot example. knitr::kable(city_year) city year turnout Atlanta 1981 43 Atlanta 1999 45 Atlanta 2003 47 Dover 1981 78 Dover 1999 81 Dover 2003 84 Rochester 1981 37 Rochester 1999 47 Rochester 2003 57 We can see that the combination of city and year are what would create a unique identifier for each observation in the dataset. The code below creates that key variable. # assign dataset to itself city_year &lt;- city_year |&gt; # use mutate to create `key` set to `paste()` mutate(key = paste( # list the variables that uniquely identify observations city, year, # set a value for the `sep` argument sep = &quot;-&quot; )) # check our work -- the number of unique values in `key` should equal the # total number of observations length(unique(city_year$key)) == nrow(city_year) ## [1] TRUE 3.14.3 Troubleshooting There are times when the length of a ‘key’ variable will not be equal to the total number of observations. For example, this will not be true for data that requires a wide pivot. In those circumstances you may want to create the key variable first, and then use the key variable for the id_cols argument in pivot_wider(). There is nothing special about using the dash, “-”, as the separator. You can substitute another symbol if you prefer. Just make sure that the symbol is in quotation marks. "],["merge.html", "3.15 Merge Multiple Datasets Together", " 3.15 Merge Multiple Datasets Together Data collection is rarely perfect. We often find that one dataset has some good potential dependent variables and a different dataset has good potential independent variables. In these circumstances, we need to merge the data together. 3.15.1 Problem You want to merge two datasets. 3.15.2 Solution Identify the ‘key’ variable that identifies the unique observations in both datasets. That is, each dataset should have the same ‘key’ variable. If a ‘key’ variable does not already exist, then create a key variable. For the secondary dataset, use select() to include only the variables that you need to merge. Remember that the ‘key’ variable will be one of the variables that you select. Create a new data object. Assign the dataset that you want to keep all of the observations of to the new object. Use the pipe operator |&gt; at the end of that line of code. Use the left_join() function to combine the datasets. The first argument is the name of the dataset that you are merging with your new data object. Set the by argument equal to the name of your ‘key’ variable in quotation marks. # Assign the dataset to a new data object new_data &lt;- old_data |&gt; # Merge using the `left_join()` function left_join(other_data, by = &#39;key&#39;) Below we will merge data on voter turnout for three cities across three years, city_year, with data on protest participation for three cities across three years, urban3. The ‘key’ to merge these data should be a combination of the name of the city and the year for the data. # long pivot of `urban3` # assign the old dataset to a new object protest_year &lt;- urban3 |&gt; # use pivot_longer() pivot_longer( # use `cols` to specify the variables that are being collapsed cols = `1981`:`2003`, # use `names_to` to specify the new variable that holds the column names names_to = &quot;year&quot;, # use `values_to` to specify the variable that holds the new values values_to = &quot;protest&quot; ) |&gt; # create the &#39;key&#39; variable mutate(key = paste( # list the variables that uniquely identify observations city, year, # set a value for the `sep` argument sep = &quot;-&quot; )) |&gt; # select only the columns you want to merge select(key, protest) # city-year and protest_year # Assign the dataset to a new data object participation &lt;- city_year |&gt; # Merge using the `left_join()` function left_join(protest_year, by = &#39;key&#39;) |&gt; # relocate the &#39;key&#39; variable to the front relocate(key) # check our work knitr::kable(participation) key city year turnout protest Atlanta-1981 Atlanta 1981 43 12 Atlanta-1999 Atlanta 1999 45 14 Atlanta-2003 Atlanta 2003 47 16 Dover-1981 Dover 1981 78 29 Dover-1999 Dover 1999 81 32 Dover-2003 Dover 2003 84 35 Rochester-1981 Rochester 1981 37 52 Rochester-1999 Rochester 1999 47 62 Rochester-2003 Rochester 2003 57 72 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
